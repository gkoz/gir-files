<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="Gdk" version="4.0"/>
  <package name="gtk4"/>
  <c:include name="gsk/gsk.h"/>
  <namespace name="Gsk" version="4.0" shared-library="libgtk-4.so.0" c:identifier-prefixes="Gsk" c:symbol-prefixes="gsk">
    <function-macro name="BROADWAY_RENDERER" c:identifier="GSK_BROADWAY_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_CLASS" c:identifier="GSK_BROADWAY_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_GET_CLASS" c:identifier="GSK_BROADWAY_RENDERER_GET_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="BlendMode" glib:type-name="GskBlendMode" glib:get-type="gsk_blend_mode_get_type" c:type="GskBlendMode">
      <doc xml:space="preserve">The blend modes available for render nodes.

The implementation of each blend mode is deferred to the
rendering pipeline.

See https://www.w3.org/TR/compositing-1/#blending for more information
on blending and blend modes.</doc>
      <member name="default" value="0" c:identifier="GSK_BLEND_MODE_DEFAULT" glib:nick="default">
        <doc xml:space="preserve">The default blend mode, which specifies no blending</doc>
      </member>
      <member name="multiply" value="1" c:identifier="GSK_BLEND_MODE_MULTIPLY" glib:nick="multiply">
        <doc xml:space="preserve">The source color is multiplied by the destination
  and replaces the destination</doc>
      </member>
      <member name="screen" value="2" c:identifier="GSK_BLEND_MODE_SCREEN" glib:nick="screen">
        <doc xml:space="preserve">Multiplies the complements of the destination and source
  color values, then complements the result.</doc>
      </member>
      <member name="overlay" value="3" c:identifier="GSK_BLEND_MODE_OVERLAY" glib:nick="overlay">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the
  destination color value. This is the inverse of hard-list</doc>
      </member>
      <member name="darken" value="4" c:identifier="GSK_BLEND_MODE_DARKEN" glib:nick="darken">
        <doc xml:space="preserve">Selects the darker of the destination and source colors</doc>
      </member>
      <member name="lighten" value="5" c:identifier="GSK_BLEND_MODE_LIGHTEN" glib:nick="lighten">
        <doc xml:space="preserve">Selects the lighter of the destination and source colors</doc>
      </member>
      <member name="color_dodge" value="6" c:identifier="GSK_BLEND_MODE_COLOR_DODGE" glib:nick="color-dodge">
        <doc xml:space="preserve">Brightens the destination color to reflect the source color</doc>
      </member>
      <member name="color_burn" value="7" c:identifier="GSK_BLEND_MODE_COLOR_BURN" glib:nick="color-burn">
        <doc xml:space="preserve">Darkens the destination color to reflect the source color</doc>
      </member>
      <member name="hard_light" value="8" c:identifier="GSK_BLEND_MODE_HARD_LIGHT" glib:nick="hard-light">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the source color value</doc>
      </member>
      <member name="soft_light" value="9" c:identifier="GSK_BLEND_MODE_SOFT_LIGHT" glib:nick="soft-light">
        <doc xml:space="preserve">Darkens or lightens the colors, depending on the source color value</doc>
      </member>
      <member name="difference" value="10" c:identifier="GSK_BLEND_MODE_DIFFERENCE" glib:nick="difference">
        <doc xml:space="preserve">Subtracts the darker of the two constituent colors from the lighter color</doc>
      </member>
      <member name="exclusion" value="11" c:identifier="GSK_BLEND_MODE_EXCLUSION" glib:nick="exclusion">
        <doc xml:space="preserve">Produces an effect similar to that of the difference mode but lower in contrast</doc>
      </member>
      <member name="color" value="12" c:identifier="GSK_BLEND_MODE_COLOR" glib:nick="color">
        <doc xml:space="preserve">Creates a color with the hue and saturation of the source color and the luminosity of the destination color</doc>
      </member>
      <member name="hue" value="13" c:identifier="GSK_BLEND_MODE_HUE" glib:nick="hue">
        <doc xml:space="preserve">Creates a color with the hue of the source color and the saturation and luminosity of the destination color</doc>
      </member>
      <member name="saturation" value="14" c:identifier="GSK_BLEND_MODE_SATURATION" glib:nick="saturation">
        <doc xml:space="preserve">Creates a color with the saturation of the source color and the hue and luminosity of the destination color</doc>
      </member>
      <member name="luminosity" value="15" c:identifier="GSK_BLEND_MODE_LUMINOSITY" glib:nick="luminosity">
        <doc xml:space="preserve">Creates a color with the luminosity of the source color and the hue and saturation of the destination color</doc>
      </member>
    </enumeration>
    <class name="BlendNode" c:symbol-prefix="blend_node" c:type="GskBlendNode" parent="RenderNode" glib:type-name="GskBlendNode" glib:get-type="gsk_blend_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_blend_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will use @blend_mode to blend the @top
node onto the @bottom node.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="BlendNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">The bottom node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">The node to be blended onto the @bottom node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="blend_mode" transfer-ownership="none">
            <doc xml:space="preserve">The blend mode to use</doc>
            <type name="BlendMode" c:type="GskBlendMode"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blend_mode" c:identifier="gsk_blend_node_get_blend_mode">
        <doc xml:space="preserve">Retrieves the blend mode used by @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blend mode</doc>
          <type name="BlendMode" c:type="GskBlendMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bottom_child" c:identifier="gsk_blend_node_get_bottom_child">
        <doc xml:space="preserve">Retrieves the bottom #GskRenderNode child of the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bottom child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_top_child" c:identifier="gsk_blend_node_get_top_child">
        <doc xml:space="preserve">Retrieves the top #GskRenderNode child of the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the top child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BlurNode" c:symbol-prefix="blur_node" c:type="GskBlurNode" parent="RenderNode" glib:type-name="GskBlurNode" glib:get-type="gsk_blur_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_blur_node_new">
        <doc xml:space="preserve">Creates a render node that blurs the child.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GskRenderNode</doc>
          <type name="BlurNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">the child node to blur</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the blur radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_blur_node_get_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode of the blur @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blurred child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur #GskRenderNode</doc>
            <type name="BlurNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_radius" c:identifier="gsk_blur_node_get_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur #GskRenderNode</doc>
            <type name="BlurNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BorderNode" c:symbol-prefix="border_node" c:type="GskBorderNode" parent="RenderNode" glib:type-name="GskBorderNode" glib:get-type="gsk_border_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_border_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will stroke a border rectangle inside the
given @outline. The 4 sides of the border can have different widths and
colors.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="BorderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect describing the outline of the border</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="border_width" transfer-ownership="none">
            <doc xml:space="preserve">the stroke width of the border on
    the top, right, bottom and left side respectively.</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="border_color" transfer-ownership="none">
            <doc xml:space="preserve">the color used on the top, right,
    bottom and left side.</doc>
            <array zero-terminated="0" c:type="const GdkRGBA*" fixed-size="4">
              <type name="Gdk.RGBA" c:type="GdkRGBA"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="peek_colors" c:identifier="gsk_border_node_peek_colors">
        <doc xml:space="preserve">Retrieves the colors of the border.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 #GdkRGBA structs
    for the top, right, bottom and left color of the border</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_outline" c:identifier="gsk_border_node_peek_outline">
        <doc xml:space="preserve">Retrieves the outline of the border.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the outline of the border</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_widths" c:identifier="gsk_border_node_peek_widths">
        <doc xml:space="preserve">Retrieves the stroke widths of the border.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 floats for the top,
    right, bottom and left stroke width of the border</doc>
          <type name="gfloat" c:type="const float*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BroadwayRenderer" c:symbol-prefix="broadway_renderer" c:type="GskBroadwayRenderer" parent="Renderer" glib:type-name="GskBroadwayRenderer" glib:get-type="gsk_broadway_renderer_get_type" glib:type-struct="BroadwayRendererClass">
      
      <constructor name="new" c:identifier="gsk_broadway_renderer_new">
        <doc xml:space="preserve">Creates a new Broadway renderer.

The Broadway renderer is the default renderer for the broadway backend.
It will only work with broadway surfaces, otherwise it will fail the
call to gsk_renderer_realize().

This function is only available when GTK was compiled with Broadway
support.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Broadway renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="BroadwayRendererClass" c:type="GskBroadwayRendererClass" disguised="1" glib:is-gtype-struct-for="BroadwayRenderer">
      
    </record>
    <function-macro name="CAIRO_RENDERER" c:identifier="GSK_CAIRO_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_CLASS" c:identifier="GSK_CAIRO_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_GET_CLASS" c:identifier="GSK_CAIRO_RENDERER_GET_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="CairoNode" c:symbol-prefix="cairo_node" c:type="GskCairoNode" parent="RenderNode" glib:type-name="GskCairoNode" glib:get-type="gsk_cairo_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_cairo_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render a cairo surface
into the area given by @bounds. You can draw to the cairo
surface using gsk_cairo_node_get_draw_context()</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="CairoNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render to</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_draw_context" c:identifier="gsk_cairo_node_get_draw_context">
        <doc xml:space="preserve">Creates a Cairo context for drawing using the surface associated
to the render node.

If no surface exists yet, a surface will be created optimized for
rendering to @renderer.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a Cairo context used for drawing; use
  cairo_destroy() when done drawing</doc>
          <type name="cairo.Context" c:type="cairo_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_surface" c:identifier="gsk_cairo_node_peek_surface">
        <doc xml:space="preserve">Retrieves the Cairo surface used by the render node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a Cairo surface</doc>
          <type name="cairo.Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="CairoRenderer" c:symbol-prefix="cairo_renderer" c:type="GskCairoRenderer" parent="Renderer" glib:type-name="GskCairoRenderer" glib:get-type="gsk_cairo_renderer_get_type" glib:type-struct="CairoRendererClass">
      
      <constructor name="new" c:identifier="gsk_cairo_renderer_new">
        <doc xml:space="preserve">Creates a new Cairo renderer.

The Cairo renderer is the fallback renderer drawing in ways similar
to how GTK 3 drew its content. Its primary use is as comparison tool.

The Cairo renderer is incomplete. It cannot render 3D transformed
content and will instead render an error marker. Its usage should be
avoided.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Cairo renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="CairoRendererClass" c:type="GskCairoRendererClass" disguised="1" glib:is-gtype-struct-for="CairoRenderer">
      
    </record>
    <class name="ClipNode" c:symbol-prefix="clip_node" c:type="GskClipNode" parent="RenderNode" glib:type-name="GskClipNode" glib:get-type="gsk_clip_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_clip_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a clip @GskRenderNode</doc>
            <type name="ClipNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_clip" c:identifier="gsk_clip_node_peek_clip">
        <doc xml:space="preserve">Retrieves the clip rectangle for @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a clip rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskClipNode</doc>
            <type name="ClipNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorMatrixNode" c:symbol-prefix="color_matrix_node" c:type="GskColorMatrixNode" parent="RenderNode" glib:type-name="GskColorMatrixNode" glib:get-type="gsk_color_matrix_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_color_matrix_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@color_matrix.

In particular, the node will transform the operation

|[&lt;!-- language="plain" --&gt;
  pixel = color_matrix * pixel + color_offset
]|

for every pixel.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="color_matrix" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to apply</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="color_offset" transfer-ownership="none">
            <doc xml:space="preserve">Values to add to the color</doc>
            <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_color_matrix_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting its colors modified by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting its colors modified</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color_matrix" c:identifier="gsk_color_matrix_node_peek_color_matrix">
        <doc xml:space="preserve">Retrieves the color matrix used by the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a 4x4 color matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color_offset" c:identifier="gsk_color_matrix_node_peek_color_offset">
        <doc xml:space="preserve">Retrieves the color offset used by the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color vector</doc>
          <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorNode" c:symbol-prefix="color_node" c:type="GskColorNode" parent="RenderNode" glib:type-name="GskColorNode" glib:get-type="gsk_color_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_color_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the color specified by @rgba into
the area given by @bounds.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ColorNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="rgba" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkRGBA specifying a color</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the color into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="peek_color" c:identifier="gsk_color_node_peek_color">
        <doc xml:space="preserve">Retrieves the color of the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the node</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskColorNode</doc>
            <type name="ColorNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="ColorStop" c:type="GskColorStop">
      
      <field name="offset" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
    </record>
    <class name="ContainerNode" c:symbol-prefix="container_node" c:type="GskContainerNode" parent="RenderNode" glib:type-name="GskContainerNode" glib:get-type="gsk_container_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_container_node_new">
        <doc xml:space="preserve">Creates a new #GskRenderNode instance for holding the given @children.
The new node will acquire a reference to each of the children.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GskRenderNode</doc>
          <type name="ContainerNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">The children of the node</doc>
            <array length="1" zero-terminated="0" c:type="GskRenderNode**">
              <type name="RenderNode" c:type="GskRenderNode*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">Number of children in the @children array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_container_node_get_child">
        <doc xml:space="preserve">Gets one of the children of @container.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @idx'th child of @container</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container #GskRenderNode</doc>
            <type name="ContainerNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the position of the child to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_children" c:identifier="gsk_container_node_get_n_children">
        <doc xml:space="preserve">Retrieves the number of direct children of @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children of the #GskRenderNode</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container #GskRenderNode</doc>
            <type name="ContainerNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="Corner" glib:type-name="GskCorner" glib:get-type="gsk_corner_get_type" c:type="GskCorner">
      <doc xml:space="preserve">The corner indices used by #GskRoundedRect.</doc>
      <member name="top_left" value="0" c:identifier="GSK_CORNER_TOP_LEFT" glib:nick="top-left">
        <doc xml:space="preserve">The top left corner</doc>
      </member>
      <member name="top_right" value="1" c:identifier="GSK_CORNER_TOP_RIGHT" glib:nick="top-right">
        <doc xml:space="preserve">The top right corner</doc>
      </member>
      <member name="bottom_right" value="2" c:identifier="GSK_CORNER_BOTTOM_RIGHT" glib:nick="bottom-right">
        <doc xml:space="preserve">The bottom right corner</doc>
      </member>
      <member name="bottom_left" value="3" c:identifier="GSK_CORNER_BOTTOM_LEFT" glib:nick="bottom-left">
        <doc xml:space="preserve">The bottom left corner</doc>
      </member>
    </enumeration>
    <class name="CrossFadeNode" c:symbol-prefix="cross_fade_node" c:type="GskCrossFadeNode" parent="RenderNode" glib:type-name="GskCrossFadeNode" glib:get-type="gsk_cross_fade_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_cross_fade_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will do a cross-fade between @start and @end.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="CrossFadeNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">The start node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">The node to be cross_fadeed onto the @start node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">How far the fade has progressed from start to end. The value will
    be clamped to the range [0 ... 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_end_child" c:identifier="gsk_cross_fade_node_get_end_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode at the end of the cross-fade.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_progress" c:identifier="gsk_cross_fade_node_get_progress">
        <doc xml:space="preserve">Retrieves the progress value of the cross fade.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the progress value, between 0 and 1</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start_child" c:identifier="gsk_cross_fade_node_get_start_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode at the beginning of the cross-fade.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="DebugNode" c:symbol-prefix="debug_node" c:type="GskDebugNode" parent="RenderNode" glib:type-name="GskDebugNode" glib:get-type="gsk_debug_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_debug_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will add debug information about
the given @child.

Adding this node has no visual effect.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="DebugNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to add debug info for</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="message" transfer-ownership="full">
            <doc xml:space="preserve">The debug message</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_debug_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug #GskRenderNode</doc>
            <type name="DebugNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="gsk_debug_node_get_message">
        <doc xml:space="preserve">Gets the debug message that was set on this node</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The debug message</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug #GskRenderNode</doc>
            <type name="DebugNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="GLRenderer" c:symbol-prefix="gl_renderer" c:type="GskGLRenderer" parent="Renderer" glib:type-name="GskGLRenderer" glib:get-type="gsk_gl_renderer_get_type" glib:type-struct="GLRendererClass">
      
      <constructor name="new" c:identifier="gsk_gl_renderer_new">
        <doc xml:space="preserve">Creates a new #GskRenderer using OpenGL. This is the default renderer
used by GTK.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new GL renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="GLRendererClass" c:type="GskGLRendererClass" disguised="1" glib:is-gtype-struct-for="GLRenderer">
      
    </record>
    <function-macro name="GL_RENDERER" c:identifier="GSK_GL_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_CLASS" c:identifier="GSK_GL_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_GET_CLASS" c:identifier="GSK_GL_RENDERER_GET_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BROADWAY_RENDERER" c:identifier="GSK_IS_BROADWAY_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BROADWAY_RENDERER_CLASS" c:identifier="GSK_IS_BROADWAY_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER" c:identifier="GSK_IS_CAIRO_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER_CLASS" c:identifier="GSK_IS_CAIRO_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER" c:identifier="GSK_IS_GL_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER_CLASS" c:identifier="GSK_IS_GL_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDERER" c:identifier="GSK_IS_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDER_NODE" c:identifier="GSK_IS_RENDER_NODE" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER" c:identifier="GSK_IS_VULKAN_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER_CLASS" c:identifier="GSK_IS_VULKAN_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="InsetShadowNode" c:symbol-prefix="inset_shadow_node" c:type="GskInsetShadowNode" parent="RenderNode" glib:type-name="GskInsetShadowNode" glib:get-type="gsk_inset_shadow_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_inset_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render an inset shadow
into the box given by @outline.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="InsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region containing the shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_inset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius to apply to the shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_inset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the inset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_inset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the inset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_inset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads inwards.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color" c:identifier="gsk_inset_shadow_node_peek_color">
        <doc xml:space="preserve">Retrieves the color of the inset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_outline" c:identifier="gsk_inset_shadow_node_peek_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the inset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="LinearGradientNode" c:symbol-prefix="linear_gradient_node" c:type="GskLinearGradientNode" parent="RenderNode" glib:type-name="GskLinearGradientNode" glib:get-type="gsk_linear_gradient_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will create a linear gradient from the given
points and color stops, and render that into the area given by @bounds.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="LinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_n_color_stops" c:identifier="gsk_linear_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color_stops" c:identifier="gsk_linear_gradient_node_peek_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_end" c:identifier="gsk_linear_gradient_node_peek_end">
        <doc xml:space="preserve">Retrieves the final point of the linear gradient.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the final point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_start" c:identifier="gsk_linear_gradient_node_peek_start">
        <doc xml:space="preserve">Retrieves the initial point of the linear gradient.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initial point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="OpacityNode" c:symbol-prefix="opacity_node" c:type="GskOpacityNode" parent="RenderNode" glib:type-name="GskOpacityNode" glib:get-type="gsk_opacity_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_opacity_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@opacity.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="OpacityNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="opacity" transfer-ownership="none">
            <doc xml:space="preserve">The opacity to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_opacity_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting opacityed by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting opacityed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an opacity</doc>
            <type name="OpacityNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_opacity" c:identifier="gsk_opacity_node_get_opacity">
        <doc xml:space="preserve">Gets the transparency factor for an opacity node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the opacity factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an opacity</doc>
            <type name="OpacityNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="OutsetShadowNode" c:symbol-prefix="outset_shadow_node" c:type="GskOutsetShadowNode" parent="RenderNode" glib:type-name="GskOutsetShadowNode" glib:get-type="gsk_outset_shadow_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_outset_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render an outset shadow
around the box given by @outline.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region surrounded by shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_outset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_outset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the outset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_outset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the outset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_outset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads outwards.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color" c:identifier="gsk_outset_shadow_node_peek_color">
        <doc xml:space="preserve">Retrieves the color of the outset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_outline" c:identifier="gsk_outset_shadow_node_peek_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the outset shadow.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="ParseErrorFunc" c:type="GskParseErrorFunc" introspectable="0">
      <doc xml:space="preserve">The type of callback that is called when a parse error occurs
during deserialization of node data.</doc>
      
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="section" transfer-ownership="none">
          <doc xml:space="preserve">the #GtkCssSection where the error occurred</doc>
          <type c:type="gconstpointer" name="gconstpointer"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the error</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="RENDERER" c:identifier="GSK_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUNDED_RECT_INIT" c:identifier="GSK_ROUNDED_RECT_INIT" introspectable="0">
      <doc xml:space="preserve">Initializes a #GskRoundedRect when declaring it.
All corner sizes will be initialized to 0.</doc>
      
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate of the origin</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate of the origin</doc>
        </parameter>
        <parameter name="_w">
          <doc xml:space="preserve">the width</doc>
        </parameter>
        <parameter name="_h">
          <doc xml:space="preserve">the height</doc>
        </parameter>
      </parameters>
    </function-macro>
    <class name="RenderNode" c:symbol-prefix="render_node" c:type="GskRenderNode" abstract="1" glib:type-name="GskRenderNode" glib:get-type="gsk_render_node_get_type" glib:fundamental="1" glib:ref-func="gsk_render_node_ref" glib:unref-func="gsk_render_node_unref">
      <doc xml:space="preserve">A node in the render tree.</doc>
      <function name="deserialize" c:identifier="gsk_render_node_deserialize" introspectable="0">
        <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
        
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the bytes containing the data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="error_func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="2">
            <doc xml:space="preserve">Callback on parsing errors or %NULL</doc>
            <type name="ParseErrorFunc" c:type="GskParseErrorFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
            <doc xml:space="preserve">user_data for @error_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="draw" c:identifier="gsk_render_node_draw">
        <doc xml:space="preserve">Draw the contents of @node to the given cairo context.

Typically, you'll use this function to implement fallback rendering
of #GskRenderNodes on an intermediate Cairo context, instead of using
the drawing context associated to a #GdkSurface's rendering buffer.

For advanced nodes that cannot be supported using Cairo, in particular
for nodes doing 3D operations, this function may fail.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">cairo context to draw to</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gsk_render_node_get_bounds">
        <doc xml:space="preserve">Retrieves the boundaries of the @node. The node will not draw outside
of its boundaries.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="bounds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the boundaries</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_node_type" c:identifier="gsk_render_node_get_node_type">
        <doc xml:space="preserve">Returns the type of the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #GskRenderNode</doc>
          <type name="RenderNodeType" c:type="GskRenderNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_render_node_ref">
        <doc xml:space="preserve">Acquires a reference on the given #GskRenderNode.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GskRenderNode with an additional reference</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="gsk_render_node_serialize">
        <doc xml:space="preserve">Serializes the @node for later deserialization via
gsk_render_node_deserialize(). No guarantees are made about the format
used other than that the same version of GTK+ will be able to deserialize
the result of a call to gsk_render_node_serialize() and
gsk_render_node_deserialize() will correctly reject files it cannot open
that were created with previous versions of GTK+.

The intended use of this functions is testing, benchmarking and debugging.
The format is not meant as a permanent storage format.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes representing the node.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_render_node_unref">
        <doc xml:space="preserve">Releases a reference on the given #GskRenderNode.

If the reference was the last, the resources associated to the @node are
freed.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_file" c:identifier="gsk_render_node_write_to_file" throws="1">
        <doc xml:space="preserve">This function is equivalent to calling gsk_render_node_serialize()
followed by g_file_set_contents(). See those two functions for details
on the arguments.

It is mostly intended for use inside a debugger to quickly dump a render
node to a file for later inspection.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to save it to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="RenderNodeType" glib:type-name="GskRenderNodeType" glib:get-type="gsk_render_node_type_get_type" c:type="GskRenderNodeType">
      <doc xml:space="preserve">The type of a node determines what the node is rendering.</doc>
      <member name="not_a_render_node" value="0" c:identifier="GSK_NOT_A_RENDER_NODE" glib:nick="not-a-render-node">
        <doc xml:space="preserve">Error type. No node will ever have this type.</doc>
      </member>
      <member name="container_node" value="1" c:identifier="GSK_CONTAINER_NODE" glib:nick="container-node">
        <doc xml:space="preserve">A node containing a stack of children</doc>
      </member>
      <member name="cairo_node" value="2" c:identifier="GSK_CAIRO_NODE" glib:nick="cairo-node">
        <doc xml:space="preserve">A node drawing a #cairo_surface_t</doc>
      </member>
      <member name="color_node" value="3" c:identifier="GSK_COLOR_NODE" glib:nick="color-node">
        <doc xml:space="preserve">A node drawing a single color rectangle</doc>
      </member>
      <member name="linear_gradient_node" value="4" c:identifier="GSK_LINEAR_GRADIENT_NODE" glib:nick="linear-gradient-node">
        <doc xml:space="preserve">A node drawing a linear gradient</doc>
      </member>
      <member name="repeating_linear_gradient_node" value="5" c:identifier="GSK_REPEATING_LINEAR_GRADIENT_NODE" glib:nick="repeating-linear-gradient-node">
        <doc xml:space="preserve">A node drawing a repeating linear gradient</doc>
      </member>
      <member name="border_node" value="6" c:identifier="GSK_BORDER_NODE" glib:nick="border-node">
        <doc xml:space="preserve">A node stroking a border around an area</doc>
      </member>
      <member name="texture_node" value="7" c:identifier="GSK_TEXTURE_NODE" glib:nick="texture-node">
        <doc xml:space="preserve">A node drawing a #GdkTexture</doc>
      </member>
      <member name="inset_shadow_node" value="8" c:identifier="GSK_INSET_SHADOW_NODE" glib:nick="inset-shadow-node">
        <doc xml:space="preserve">A node drawing an inset shadow</doc>
      </member>
      <member name="outset_shadow_node" value="9" c:identifier="GSK_OUTSET_SHADOW_NODE" glib:nick="outset-shadow-node">
        <doc xml:space="preserve">A node drawing an outset shadow</doc>
      </member>
      <member name="transform_node" value="10" c:identifier="GSK_TRANSFORM_NODE" glib:nick="transform-node">
        <doc xml:space="preserve">A node that renders its child after applying a matrix transform</doc>
      </member>
      <member name="opacity_node" value="11" c:identifier="GSK_OPACITY_NODE" glib:nick="opacity-node">
        <doc xml:space="preserve">A node that changes the opacity of its child</doc>
      </member>
      <member name="color_matrix_node" value="12" c:identifier="GSK_COLOR_MATRIX_NODE" glib:nick="color-matrix-node">
        <doc xml:space="preserve">A node that applies a color matrix to every pixel</doc>
      </member>
      <member name="repeat_node" value="13" c:identifier="GSK_REPEAT_NODE" glib:nick="repeat-node">
        <doc xml:space="preserve">A node that repeats the child's contents</doc>
      </member>
      <member name="clip_node" value="14" c:identifier="GSK_CLIP_NODE" glib:nick="clip-node">
        <doc xml:space="preserve">A node that clips its child to a rectangular area</doc>
      </member>
      <member name="rounded_clip_node" value="15" c:identifier="GSK_ROUNDED_CLIP_NODE" glib:nick="rounded-clip-node">
        <doc xml:space="preserve">A node that clips its child to a rounded rectangle</doc>
      </member>
      <member name="shadow_node" value="16" c:identifier="GSK_SHADOW_NODE" glib:nick="shadow-node">
        <doc xml:space="preserve">A node that draws a shadow below its child</doc>
      </member>
      <member name="blend_node" value="17" c:identifier="GSK_BLEND_NODE" glib:nick="blend-node">
        <doc xml:space="preserve">A node that blends two children together</doc>
      </member>
      <member name="cross_fade_node" value="18" c:identifier="GSK_CROSS_FADE_NODE" glib:nick="cross-fade-node">
        <doc xml:space="preserve">A node that cross-fades between two children</doc>
      </member>
      <member name="text_node" value="19" c:identifier="GSK_TEXT_NODE" glib:nick="text-node">
        <doc xml:space="preserve">A node containing a glyph string</doc>
      </member>
      <member name="blur_node" value="20" c:identifier="GSK_BLUR_NODE" glib:nick="blur-node">
        <doc xml:space="preserve">A node that applies a blur</doc>
      </member>
      <member name="debug_node" value="21" c:identifier="GSK_DEBUG_NODE" glib:nick="debug-node">
        <doc xml:space="preserve">Debug information that does not affect the rendering</doc>
      </member>
    </enumeration>
    <class name="Renderer" c:symbol-prefix="renderer" c:type="GskRenderer" parent="GObject.Object" abstract="1" glib:type-name="GskRenderer" glib:get-type="gsk_renderer_get_type" glib:type-struct="RendererClass">
      
      <constructor name="new_for_surface" c:identifier="gsk_renderer_new_for_surface">
        <doc xml:space="preserve">Creates an appropriate #GskRenderer instance for the given @surface.

The renderer will be realized when it is returned.</doc>
        
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GskRenderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
        <parameters>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkSurface</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_surface" c:identifier="gsk_renderer_get_surface">
        <doc xml:space="preserve">Retrieves the #GdkSurface set using gsk_renderer_realize(). If the renderer
has not been realized yet, %NULL will be returned.</doc>
        
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GdkSurface</doc>
          <type name="Gdk.Surface" c:type="GdkSurface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_realized" c:identifier="gsk_renderer_is_realized">
        <doc xml:space="preserve">Checks whether the @renderer is realized or not.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the #GskRenderer was realized, and %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="realize" c:identifier="gsk_renderer_realize" throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.</doc>
        
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkSurface renderer will be used on</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="gsk_renderer_render">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
ensuring that the given @region gets redrawn.

Renderers must ensure that changes of the contents given by the @root
node as well as the area given by @region are redrawn. They are however
free to not redraw any pixel outside of @region if they can guarantee that
it didn't change.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="region" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #cairo_region_t that must be redrawn or %NULL
    for the whole window</doc>
            <type name="cairo.Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_texture" c:identifier="gsk_renderer_render_texture">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
to a #GdkTexture.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.

If you want to apply any transformations to @root, you should put it into a
transform node and pass that node instead.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GdkTexture with the rendered contents of @root.</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="viewport" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section to draw or %NULL to use @root's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unrealize" c:identifier="gsk_renderer_unrealize">
        <doc xml:space="preserve">Releases all the resources created by gsk_renderer_realize().</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="realized" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="surface" transfer-ownership="none">
        <type name="Gdk.Surface"/>
      </property>
    </class>
    <record name="RendererClass" c:type="GskRendererClass" disguised="1" glib:is-gtype-struct-for="Renderer">
      
    </record>
    <class name="RepeatNode" c:symbol-prefix="repeat_node" c:type="GskRepeatNode" parent="RenderNode" glib:type-name="GskRepeatNode" glib:get-type="gsk_repeat_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_repeat_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will repeat the drawing of @child across
the given @bounds.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RepeatNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">The bounds of the area to be painted</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to repeat</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="child_bounds" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The area of the child to repeat or %NULL to
    use the child's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_repeat_node_get_child">
        <doc xml:space="preserve">Retrieves the child of @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat #GskRenderNode</doc>
            <type name="RepeatNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_child_bounds" c:identifier="gsk_repeat_node_peek_child_bounds">
        <doc xml:space="preserve">Retrieves the bounding rectangle of the child of @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a bounding rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat #GskRenderNode</doc>
            <type name="RepeatNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="RepeatingLinearGradientNode" c:symbol-prefix="repeating_linear_gradient_node" c:type="GskRepeatingLinearGradientNode" parent="RenderNode" glib:type-name="GskRepeatingLinearGradientNode" glib:get-type="gsk_repeating_linear_gradient_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_repeating_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will create a repeating linear gradient
from the given points and color stops, and render that into the area
given by @bounds.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RepeatingLinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="RoundedClipNode" c:symbol-prefix="rounded_clip_node" c:type="GskRoundedClipNode" parent="RenderNode" glib:type-name="GskRoundedClipNode" glib:get-type="gsk_rounded_clip_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_rounded_clip_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RoundedClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_rounded_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip #GskRenderNode</doc>
            <type name="RoundedClipNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_clip" c:identifier="gsk_rounded_clip_node_peek_clip">
        <doc xml:space="preserve">Retrievs the rounded rectangle used to clip the contents of the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip #GskRenderNode</doc>
            <type name="RoundedClipNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="RoundedRect" c:type="GskRoundedRect">
      <doc xml:space="preserve">A rectangular region with rounded corners.

Application code should normalize rectangles using gsk_rounded_rect_normalize();
this function will ensure that the bounds of the rectangle are normalized
and ensure that the corner values are positive and the corners do not overlap.
All functions taking a #GskRoundedRect as an argument will internally operate on
a normalized copy; all functions returning a #GskRoundedRect will always return
a normalized one.</doc>
      
      <field name="bounds" writable="1">
        <doc xml:space="preserve">the bounds of the rectangle</doc>
        <type name="Graphene.Rect" c:type="graphene_rect_t"/>
      </field>
      <field name="corner" writable="1">
        <doc xml:space="preserve">the size of the 4 rounded corners</doc>
        <array zero-terminated="0" fixed-size="4">
          <type name="Graphene.Size" c:type="graphene_size_t"/>
        </array>
      </field>
      <method name="contains_point" c:identifier="gsk_rounded_rect_contains_point">
        <doc xml:space="preserve">Checks if the given @point is inside the rounded rectangle. This function
returns %FALSE if the point is in the rounded corner areas.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @point is inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to check</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect" c:identifier="gsk_rounded_rect_contains_rect">
        <doc xml:space="preserve">Checks if the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect extends into one of the rounded
corner areas.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect is fully contained inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gsk_rounded_rect_init">
        <doc xml:space="preserve">Initializes the given #GskRoundedRect with the given values.

This function will implicitly normalize the #GskRoundedRect
before returning.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to initialize</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t describing the bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="top_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="top_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy" c:identifier="gsk_rounded_rect_init_copy">
        <doc xml:space="preserve">Initializes @self using the given @src rectangle.

This function will not normalize the #GskRoundedRect, so
make sure the source is normalized.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect" c:identifier="gsk_rounded_rect_init_from_rect">
        <doc xml:space="preserve">Initializes @self to the given @bounds and sets the radius of all
four corners to @radius.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the border radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_rect" c:identifier="gsk_rounded_rect_intersects_rect">
        <doc xml:space="preserve">Checks if part of the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect only extends into one of the rounded
corner areas but not into the rounded rectangle itself.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect intersects with the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_rectilinear" c:identifier="gsk_rounded_rect_is_rectilinear">
        <doc xml:space="preserve">Checks if all corners of @self are right angles and the
rectangle covers all of its bounds.

This information can be used to decide if gsk_clip_node_new()
or gsk_rounded_clip_node_new() should be called.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the rectangle is rectilinear</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GskRoundedRect to check</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gsk_rounded_rect_normalize">
        <doc xml:space="preserve">Normalizes the passed rectangle.

this function will ensure that the bounds of the rectangle are normalized
and ensure that the corner values are positive and the corners do not overlap.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="gsk_rounded_rect_offset">
        <doc xml:space="preserve">Offsets the bound's origin by @dx and @dy.

The size and corners of the rectangle are unchanged.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="gsk_rounded_rect_shrink">
        <doc xml:space="preserve">Shrinks (or grows) the given rectangle by moving the 4 sides
according to the offsets given. The corner radii will be changed
in a way that tries to keep the center of the corner circle intact.
This emulates CSS behavior.

This function also works for growing rectangles if you pass
negative values for the @top, @right, @bottom or @left.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resized #GskRoundedRect</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to shrink or grow</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the top side downwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the right side to the left</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the bottom side upwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the left side to the right</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScalingFilter" glib:type-name="GskScalingFilter" glib:get-type="gsk_scaling_filter_get_type" c:type="GskScalingFilter">
      <doc xml:space="preserve">The filters used when scaling texture data.

The actual implementation of each filter is deferred to the
rendering pipeline.</doc>
      <member name="linear" value="0" c:identifier="GSK_SCALING_FILTER_LINEAR" glib:nick="linear">
        <doc xml:space="preserve">linear interpolation filter</doc>
      </member>
      <member name="nearest" value="1" c:identifier="GSK_SCALING_FILTER_NEAREST" glib:nick="nearest">
        <doc xml:space="preserve">nearest neighbor interpolation filter</doc>
      </member>
      <member name="trilinear" value="2" c:identifier="GSK_SCALING_FILTER_TRILINEAR" glib:nick="trilinear">
        <doc xml:space="preserve">linear interpolation along each axis,
  plus mipmap generation, with linear interpolation along the mipmap
  levels</doc>
      </member>
    </enumeration>
    <enumeration name="SerializationError" glib:type-name="GskSerializationError" glib:get-type="gsk_serialization_error_get_type" c:type="GskSerializationError" glib:error-domain="gsk-serialization-error-quark">
      <doc xml:space="preserve">Errors that can happen during (de)serialization.</doc>
      <member name="unsupported_format" value="0" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_FORMAT" glib:nick="unsupported-format">
        <doc xml:space="preserve">The format can not be
    identified</doc>
      </member>
      <member name="unsupported_version" value="1" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_VERSION" glib:nick="unsupported-version">
        <doc xml:space="preserve">The version of the data
    is not understood</doc>
      </member>
      <member name="invalid_data" value="2" c:identifier="GSK_SERIALIZATION_INVALID_DATA" glib:nick="invalid-data">
        <doc xml:space="preserve">The given data may not exist in
    a proper serialization</doc>
      </member>
      <function name="quark" c:identifier="gsk_serialization_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="Shadow" c:type="GskShadow">
      
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
      <field name="dx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="dy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="radius" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <class name="ShadowNode" c:symbol-prefix="shadow_node" c:type="GskShadowNode" parent="RenderNode" glib:type-name="GskShadowNode" glib:get-type="gsk_shadow_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="shadows" transfer-ownership="none">
            <doc xml:space="preserve">The shadows to apply</doc>
            <array length="2" zero-terminated="0" c:type="const GskShadow*">
              <type name="Shadow" c:type="GskShadow"/>
            </array>
          </parameter>
          <parameter name="n_shadows" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in the @shadows array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_shadow_node_get_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode of the shadow @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child render node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_shadows" c:identifier="gsk_shadow_node_get_n_shadows">
        <doc xml:space="preserve">Retrieves the number of shadows in the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of shadows.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_shadow" c:identifier="gsk_shadow_node_peek_shadow">
        <doc xml:space="preserve">Retrieves the shadow data at the given index @i.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the shadow data</doc>
          <type name="Shadow" c:type="const GskShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the given index</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="TextNode" c:symbol-prefix="text_node" c:type="GskTextNode" parent="RenderNode" glib:type-name="GskTextNode" glib:get-type="gsk_text_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_text_node_new">
        <doc xml:space="preserve">Creates a render node that renders the given glyphs,
Note that @color may not be used if the font contains
color glyphs.</doc>
        
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode</doc>
          <type name="TextNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="font" transfer-ownership="none">
            <doc xml:space="preserve">the #PangoFont containing the glyphs</doc>
            <type name="Pango.Font" c:type="PangoFont*"/>
          </parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve">the #PangoGlyphString to render</doc>
            <type name="Pango.GlyphString" c:type="PangoGlyphString*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the foreground color to render with</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset of the baseline</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="peek_font" c:identifier="gsk_text_node_peek_font">
        <doc xml:space="preserve">Returns the font used by the text @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font</doc>
          <type name="Pango.Font" c:type="PangoFont*"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_num_glyphs" c:identifier="gsk_text_node_get_num_glyphs">
        <doc xml:space="preserve">Retrieves the number of glyphs in the text node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of glyphs</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="gsk_text_node_get_offset">
        <doc xml:space="preserve">Retrieves the offset applied to the text.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a point with the horizontal and vertical offsets</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_color_glyphs" c:identifier="gsk_text_node_has_color_glyphs">
        <doc xml:space="preserve">Checks whether the text @node has color glyphs.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the text node has color glyphs</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_color" c:identifier="gsk_text_node_peek_color">
        <doc xml:space="preserve">Retrieves the color used by the text @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_glyphs" c:identifier="gsk_text_node_peek_glyphs">
        <doc xml:space="preserve">Retrieves the glyph information in the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the glyph information</doc>
          <array length="0" zero-terminated="0" c:type="const PangoGlyphInfo*">
            <type name="Pango.GlyphInfo" c:type="PangoGlyphInfo"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_glyphs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of glyphs returned</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="TextureNode" c:symbol-prefix="texture_node" c:type="GskTextureNode" parent="RenderNode" glib:type-name="GskTextureNode" glib:get-type="gsk_texture_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_texture_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the given
@texture into the area given by @bounds.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="TextureNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkTexture</doc>
            <type name="Gdk.Texture" c:type="GdkTexture*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the texture into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_texture" c:identifier="gsk_texture_node_get_texture">
        <doc xml:space="preserve">Retrieves the #GdkTexture used when creating this #GskRenderNode.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GdkTexture</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode of type %GSK_TEXTURE_NODE</doc>
            <type name="TextureNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="Transform" c:type="GskTransform" glib:type-name="GskTransform" glib:get-type="gsk_transform_get_type" c:symbol-prefix="transform">
      <doc xml:space="preserve">The `GskTransform` structure contains only private data.</doc>
      
      <constructor name="new" c:identifier="gsk_transform_new">
        
        <return-value transfer-ownership="full">
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="gsk_transform_equal">
        <doc xml:space="preserve">Checks two transforms for equality.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two transforms peform the same operation.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">the first transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">the second transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_category" c:identifier="gsk_transform_get_category">
        <doc xml:space="preserve">Returns the category this transform belongs to.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The category of the transform</doc>
          <type name="TransformCategory" c:type="GskTransformCategory"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="gsk_transform_invert">
        <doc xml:space="preserve">Inverts the given transform.

If @self is not invertible, %NULL is returned.
Note that inverting %NULL also returns %NULL, which is
the correct inverse of %NULL. If you need to differentiate
between those cases, you should check @self is not %NULL
before calling this function.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The inverted transform or %NULL if the transform
    cannot be inverted.</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to invert</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matrix" c:identifier="gsk_transform_matrix">
        <doc xml:space="preserve">Multiplies @next with the given @matrix.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the matrix to multiply @next with</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="gsk_transform_perspective">
        <doc xml:space="preserve">Applies a perspective projection transform. This transform
scales points in X and Y based on their Z value, scaling
points with positive Z values away from the origin, and
those with negative Z values towards the origin. Points
on the z=0 plane are unchanged.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">distance of the z=0 plane. Lower values give a more
    flattened pyramid and therefore a more pronounced
    perspective effect.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="gsk_transform_print">
        <doc xml:space="preserve">Converts @self into a human-readable string representation suitable
for printing that can later be parsed with gsk_transform_parse().</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">The string to print into</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_transform_ref">
        <doc xml:space="preserve">Acquires a reference on the given #GskTransform.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GskTransform with an additional reference</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="gsk_transform_rotate">
        <doc xml:space="preserve">Rotates @next @angle degrees in 2D - or in 3Dspeak, around the z axis.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_3d" c:identifier="gsk_transform_rotate_3d">
        <doc xml:space="preserve">Rotates @next @angle degrees around @axis.

For a rotation in 2D space, use gsk_transform_rotate().</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">The rotation axis</doc>
            <type name="Graphene.Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="gsk_transform_scale">
        <doc xml:space="preserve">Scales @next in 2-dimensional space by the given factors.
Use gsk_transform_scale_3d() to scale in all 3 dimensions.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale_3d" c:identifier="gsk_transform_scale_3d">
        <doc xml:space="preserve">Scales @next by the given factors.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_z" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_2d" c:identifier="gsk_transform_to_2d">
        <doc xml:space="preserve">Converts a #GskTransform to a 2D transformation
matrix.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D to check.

The returned values have the following layout:

|[&lt;!-- language="plain" --&gt;
  | xx yx |   |  a  b  0 |
  | xy yy | = |  c  d  0 |
  | dx dy |   | tx ty  1 |
]|

This function can be used to convert between a #GskTransform
and a matrix type from other 2D drawing libraries, in particular
Cairo.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a 2D #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_xx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_xy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the x0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the y0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_affine" c:identifier="gsk_transform_to_affine">
        <doc xml:space="preserve">Converts a #GskTransform to 2D affine transformation
factors.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_scale_x" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
    factor in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_scale_y" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
    factor in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_matrix" c:identifier="gsk_transform_to_matrix">
        <doc xml:space="preserve">Computes the actual value of @self and stores it in @out_matrix.
The previous value of @out_matrix will be ignored.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_matrix" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to set</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gsk_transform_to_string">
        <doc xml:space="preserve">Converts a matrix into a string that is suitable for
printing and can later be parsed with gsk_transform_parse().

This is a wrapper around gsk_transform_print(), see that function
for details.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new string for @self</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_translate" c:identifier="gsk_transform_to_translate">
        <doc xml:space="preserve">Converts a #GskTransform to a translation operation.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="gsk_transform_transform">
        <doc xml:space="preserve">Applies all the operations from @other to @next.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply @other to</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_bounds" c:identifier="gsk_transform_transform_bounds">
        <doc xml:space="preserve">Transforms a #graphene_rect_t using the given transform @self.
The result is the bounding box containing the coplanar quad.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="out_rect" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed rectangle</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point" c:identifier="gsk_transform_transform_point">
        <doc xml:space="preserve">Transforms a #graphene_point_t using the given transform @self.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="out_point" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for
  the transformed point</doc>
            <type name="Graphene.Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="gsk_transform_translate">
        <doc xml:space="preserve">Translates @next in 2dimensional space by @point.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate_3d" c:identifier="gsk_transform_translate_3d">
        <doc xml:space="preserve">Translates @next by @point.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_transform_unref">
        <doc xml:space="preserve">Releases a reference on the given #GskTransform.

If the reference was the last, the resources associated to the @self are
freed.</doc>
        
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="gsk_transform_parse">
        <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform. Strings printed via gsk_transform_to_string()
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The location to put the transform in</doc>
            <type name="Transform" c:type="GskTransform**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="TransformCategory" glib:type-name="GskTransformCategory" glib:get-type="gsk_transform_category_get_type" c:type="GskTransformCategory">
      <doc xml:space="preserve">The categories of matrices relevant for GSK and GTK. Note that any
category includes matrices of all later categories. So if you want
to for example check if a matrix is a 2D matrix,
`category &gt;= GSK_TRANSFORM_CATEGORY_2D` is the way to do this.

Also keep in mind that rounding errors may cause matrices to not
conform to their categories. Otherwise, matrix operations done via
mutliplication will not worsen categories. So for the matrix
multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`.</doc>
      <member name="unknown" value="0" c:identifier="GSK_TRANSFORM_CATEGORY_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">The category of the matrix has not been
    determined.</doc>
      </member>
      <member name="any" value="1" c:identifier="GSK_TRANSFORM_CATEGORY_ANY" glib:nick="any">
        <doc xml:space="preserve">Analyzing the matrix concluded that it does
    not fit in any other category.</doc>
      </member>
      <member name="3d" value="2" c:identifier="GSK_TRANSFORM_CATEGORY_3D" glib:nick="3d">
        <doc xml:space="preserve">The matrix is a 3D matrix. This means that
    the w column (the last column) has the values (0, 0, 0, 1).</doc>
      </member>
      <member name="2d" value="3" c:identifier="GSK_TRANSFORM_CATEGORY_2D" glib:nick="2d">
        <doc xml:space="preserve">The matrix is a 2D matrix. This is equivalent
    to graphene_matrix_is_2d() returning %TRUE. In particular, this
    means that Cairo can deal with the matrix.</doc>
      </member>
      <member name="2d_affine" value="4" c:identifier="GSK_TRANSFORM_CATEGORY_2D_AFFINE" glib:nick="2d-affine">
        <doc xml:space="preserve">The matrix is a combination of 2D scale
    and 2D translation operations. In particular, this means that any
    rectangle can be transformed exactly using this matrix.</doc>
      </member>
      <member name="2d_translate" value="5" c:identifier="GSK_TRANSFORM_CATEGORY_2D_TRANSLATE" glib:nick="2d-translate">
        <doc xml:space="preserve">The matrix is a 2D translation.</doc>
      </member>
      <member name="identity" value="6" c:identifier="GSK_TRANSFORM_CATEGORY_IDENTITY" glib:nick="identity">
        <doc xml:space="preserve">The matrix is the identity matrix.</doc>
      </member>
    </enumeration>
    <class name="TransformNode" c:symbol-prefix="transform_node" c:type="GskTransformNode" parent="RenderNode" glib:type-name="GskTransformNode" glib:get-type="gsk_transform_node_get_type" glib:fundamental="1">
      <constructor name="new" c:identifier="gsk_transform_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will transform the given @child
with the given @transform.</doc>
        
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="TransformNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to transform</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none">
            <doc xml:space="preserve">The transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_transform_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting transformed by the given @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting transformed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a transform</doc>
            <type name="TransformNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transform" c:identifier="gsk_transform_node_get_transform">
        <doc xml:space="preserve">Retrieves the #GskTransform used by the @node.</doc>
        
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskTransform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a transform</doc>
            <type name="TransformNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <function-macro name="VULKAN_RENDERER" c:identifier="GSK_VULKAN_RENDERER" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_CLASS" c:identifier="GSK_VULKAN_RENDERER_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_GET_CLASS" c:identifier="GSK_VULKAN_RENDERER_GET_CLASS" introspectable="0">
      
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="VulkanRenderer" c:symbol-prefix="vulkan_renderer" c:type="GskVulkanRenderer" parent="Renderer" glib:type-name="GskVulkanRenderer" glib:get-type="gsk_vulkan_renderer_get_type" glib:type-struct="VulkanRendererClass">
      
      <constructor name="new" c:identifier="gsk_vulkan_renderer_new">
        
        <return-value transfer-ownership="full">
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="VulkanRendererClass" c:type="GskVulkanRendererClass" disguised="1" glib:is-gtype-struct-for="VulkanRenderer">
      
    </record>
    <function name="serialization_error_quark" c:identifier="gsk_serialization_error_quark" moved-to="SerializationError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="transform_parse" c:identifier="gsk_transform_parse" moved-to="Transform.parse">
      <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform. Strings printed via gsk_transform_to_string()
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
      
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to parse</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">The location to put the transform in</doc>
          <type name="Transform" c:type="GskTransform**"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
